# Конспект: `Task` и `TaskEither` — Асинхронность в fp-ts

## 1. Что такое `Task`?

`Task<A>` — это тип `fp-ts`, который представляет собой **асинхронное вычисление, которое никогда не завершается с ошибкой** и в конечном итоге производит значение типа `A`.

Ключевые особенности:
- **Ленивость (Lazy)**: В отличие от `Promise`, который запускается в момент создания, `Task` — это просто описание асинхронной операции. Он ничего не делает, пока его явно не "запустят" (вызовут как функцию). Это позволяет декларативно строить сложные асинхронные потоки, не запуская их преждевременно.
- **Отсутствие ошибок**: `Task` по своей природе не может "упасть" или быть "отклоненным" (rejected). Он всегда успешно возвращает результат.

**Аналогия из жизни**:
`Task` — это как подробный рецепт блюда, которое *гарантированно получится*, если следовать инструкциям. Сам рецепт (объект `Task`) — это просто бумага с текстом. Приготовление блюда (запуск `Task`) — это отдельный шаг, который вы совершаете, когда готовы.

**Когда использовать `Task`?**
Используйте `Task`, когда асинхронная операция не может завершиться ошибкой. На практике это встречается редко.

*Пример*: Асинхронная операция, которая ждет 1 секунду и возвращает 'готово'.
```typescript
import * as T from 'fp-ts/Task';

const waitAndSucceed: T.Task<string> = () => new Promise(resolve => {
  setTimeout(() => {
    resolve('Готово!');
  }, 1000);
});

// Чтобы запустить Task, его нужно вызвать как функцию:
waitAndSucceed().then(console.log); // Через 1 секунду выведет: 'Готово!'
```

## 2. Что такое `TaskEither`?

`TaskEither<E, A>` — это "суперкомбо" из `Task` и `Either`. Он представляет собой **асинхронное вычисление, которое может завершиться ошибкой** (тип `E`) или **успешно** (тип `A`).

По сути, это `Task<Either<E, A>>`.

Это самый распространенный и полезный инструмент для реальных асинхронных операций, потому что почти любая асинхронная операция в реальном мире может пойти не так.

**Аналогия из жизни**:
`TaskEither` — это как заказ пиццы. Вы запускаете асинхронную операцию (звоните в пиццерию). В итоге вы получите либо `Right<Пицца>` (успех), либо `Left<"Простите, у нас закончилась моцарелла">` (ошибка).

## 3. Когда использовать `TaskEither`? (Примеры из жизни)

`TaskEither` — ваш основной инструмент для любой асинхронной операции, которая может завершиться неудачей.

1.  **Сетевые запросы (`fetch`)**:
    - **Успех (`Right`)**: Сервер ответил `200 OK` и вернул ожидаемые данные.
    - **Ошибка (`Left`)**: Нет сети, сервер вернул `500` или `404`, вернулись некорректные данные.

2.  **Работа с базой данных**:
    - **Успех (`Right`)**: Запрос в БД успешно выполнен, данные получены.
    - **Ошибка (`Left`)**: Не удалось подключиться к БД, невалидный SQL-запрос, запись не найдена.

3.  **Асинхронная работа с файловой системой**:
    - **Успех (`Right`)**: Файл успешно прочитан/записан.
    - **Ошибка (`Left`)**: Файл не найден, нет прав на чтение/запись.

4.  **Получение пользовательского ввода (наш случай)**:
    - **Успех (`Right`)**: Пользователь ввел данные.
    - **Ошибка (`Left`)**: Пользователь прервал ввод (например, нажал `Ctrl+D`).

## 4. Как создать и использовать `TaskEither`?

### `tryCatch`
Это самый частый способ создать `TaskEither` из `Promise`. Он "оборачивает" `Promise`: если `Promise` разрешается (resolves), результат попадает в `Right`; если отклоняется (rejects), ошибка попадает в `Left`.

```typescript
import * as TE from 'fp-ts/TaskEither';
import { pipe } from 'fp-ts/function';

const fetchUsers = (): TE.TaskEither<Error, unknown> =>
  TE.tryCatch(
    () => fetch('https://api.example.com/users').then(res => res.json()),
    (reason: unknown) => new Error(String(reason)) // Функция для преобразования ошибки
  );
```

### `map`, `chain`, `fold`

Они работают так же, как и у `Either`, но в асинхронном контексте. Это позволяет строить цепочки асинхронных операций, где ошибка в любой из них прерывает всю цепочку.

```typescript
// Представим, что у нас есть функции:
declare function getUser(id: number): TE.TaskEither<Error, User>;
declare function getPosts(user: User): TE.TaskEither<Error, Post[]>;
declare function getFirstPost(posts: Post[]): E.Either<Error, Post>; // Синхронная!

// Мы можем скомбинировать их:
const getFirstPostForUser = (id: number): TE.TaskEither<Error, Post> =>
  pipe(
    getUser(id),                      // TaskEither<Error, User>
    TE.chain(getPosts),               // TaskEither<Error, Post[]>
    TE.chainEitherK(getFirstPost)     // Превращает (a: A) => E.Either<E, B> в (a: A) => TE.TaskEither<E, B>
  );
```
`TE.chainEitherK` — это специальный хелпер для комбинации асинхронной и синхронной логики.

### `match`
`TE.match` (или `TE.fold`) — это способ "выйти" из `TaskEither` в конце, чтобы выполнить реальные действия (например, вывести в консоль). Он принимает две функции: одна для ошибки (`Left`), другая для успеха (`Right`).

```typescript
pipe(
  getFirstPostForUser(1),
  TE.match(
    (error) => `Ошибка: ${error.message}`,
    (post) => `Заголовок первого поста: ${post.title}`
  )
)().then(console.log); // Запускаем Task и выводим результат
```
Обрати внимание на `()()` в конце — первый вызов `match` возвращает `Task`, а второй — запускает его.

Теперь мы готовы применить это в `main.ts` для взаимодействия с игроком!
