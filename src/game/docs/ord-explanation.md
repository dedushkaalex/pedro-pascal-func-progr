# Конспект: `fp-ts/Ord`

## 1. Что такое `Ord`?

`Ord` — это тайпкласс (type class) из `fp-ts`, который используется для типов данных, обладающих **полным порядком** (total order).

Это означает, что для любых двух значений `a` и `b` мы всегда можем однозначно определить, выполняется ли одно из трех условий:
- `a` меньше `b` (`a < b`)
- `a` больше `b` (`a > b`)
- `a` равно `b` (`a === b`)

`Ord<A>` для типа `A` предоставляет функцию `compare: (x: A, y: A) => Ordering`, где `Ordering` это `1` (больше), `0` (равно) или `-1` (меньше).

## 2. Зачем нужен `Ord`?

Вместо того чтобы писать императивные `if-else` цепочки для сравнения объектов, `Ord` позволяет нам делать это в декларативном, функциональном стиле.

**Ключевые преимущества:**
- **Декларативность**: Мы описываем *правила сравнения*, а не последовательность действий. Код становится более читаемым.
- **Компонуемость**: `Ord`'ы можно комбинировать! Мы можем создать `Ord` для каждого поля объекта, а затем "собрать" из них один сложный `Ord` для всего объекта. Это **главная суперсила**, которая нам понадобится.
- **Переиспользование**: Однажды определив `Ord` для своего типа, вы можете использовать его в любом месте, где требуется сравнение (например, для сортировки).

## 3. Как использовать `Ord`?

### Базовые экземпляры

`fp-ts` уже предоставляет `Ord` для примитивных типов.
- `S.Ord` для `string`
- `N.Ord` для `number`
- `B.Ord` для `boolean`

```typescript
import * as S from 'fp-ts/string';
import * as N from 'fp-ts/number';

S.Ord.compare('a', 'b'); // -1
N.Ord.compare(2, 1);   // 1
```

### Создание своих `Ord`

#### `contramap`
Чаще всего мы хотим создать `Ord` для нашей структуры данных, основываясь на `Ord` одного из ее полей. Для этого используется `contramap`.

Он "превращает" `Ord<A>` в `Ord<B>`, если мы дадим ему функцию, которая знает, как из `B` получить `A`.

```typescript
import { contramap } from 'fp-ts/Ord';
import * as N from 'fp-ts/number';

type User = { name: string, age: number };

// Создаем Ord<User>, который сравнивает пользователей по возрасту
const byAge: Ord<User> = contramap((user: User) => user.age)(N.Ord);

byAge.compare({ name: 'A', age: 30 }, { name: 'B', age: 25 }); // 1
```

#### `reverse`
Иногда нам нужно инвертировать порядок (например, "чем меньше, тем лучше").

```typescript
import { reverse } from 'fp-ts/Ord';
import * as N from 'fp-ts/number';

const invertedOrdNumber = reverse(N.Ord);

invertedOrdNumber.compare(5, 2); // -1 (вместо 1)
```
Мы будем использовать это для пробега автомобиля.

### Комбинирование `Ord`'ов

Это самая важная часть для нашей игры. Когда нам нужно сравнить объекты по нескольким полям (сначала по одному, если они равны - по второму, и т.д.), мы "склеиваем" несколько `Ord`'ов.

Для этого существует специальная функция `concat` (или `sequenceT` из `Apply` для более чистого синтаксиса).

Представим, что нам нужно сравнить пользователей сначала по возрасту, а если возраст равен - то по имени.

```typescript
import { getSemigroup, contramap } from 'fp-ts/Ord';
import * as S from 'fp-ts/string';
import * as N from 'fp-ts/number';

// ... type User ...

// 1. Ord для сравнения по возрасту
const byAge: Ord<User> = contramap((u: User) => u.age)(N.Ord);

// 2. Ord для сравнения по имени
const byName: Ord<User> = contramap((u: User) => u.name)(S.Ord);

// 3. Получаем Semigroup, которая умеет "склеивать" Ord'ы
const semigroupUser = getSemigroup<User>();

// 4. Склеиваем! Сначала byAge, потом byName.
const byAgeThenName = semigroupUser.concat(byAge, byName);

byAgeThenName.compare({ name: 'B', age: 30 }, { name: 'A', age: 30 }); // 1 (имена B > A)
byAgeThenName.compare({ name: 'B', age: 25 }, { name: 'A', age: 30 }); // -1 (возраст 25 < 30)
```

## 4. Применение в нашей игре

Мы создадим:
1. `Ord` для `Brand`, чтобы реализовать `BMW > Audi > Ford`.
2. `Ord` для `Engine`: `дизель > бензин > электро`.
3. Используем `N.Ord` для года (чем больше, тем лучше).
4. Используем `reverse(N.Ord)` для пробега (чем меньше, тем лучше).
5. Соберем все это в один `Ord<Car>` с помощью `concat`.

Теперь, когда теория позади, перейдем к практике!
