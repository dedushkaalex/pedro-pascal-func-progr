# Конспект: `IO` — Управление синхронными эффектами

## 1. Проблема: "Грязные" функции

Функция называется "чистой", если она всегда возвращает один и тот же результат для одних и тех же аргументов и не имеет наблюдаемых побочных эффектов.

`console.log()` — это побочный эффект. Функция, которая его вызывает, по определению "грязна".

```typescript
// Грязная функция
const greet = (name: string): void => {
  console.log(`Hello, ${name}`); // Побочный эффект
};
```
Такие функции сложно тестировать и комбинировать, потому что они делают больше, чем просто возвращают значение.

## 2. Решение: `IO<A>`

`IO<A>` — это тип, представляющий **синхронное** вычисление, которое может производить побочные эффекты и возвращать значение типа `A`.

По сути, `IO<A>` — это просто обертка над функцией без аргументов: `() => A`.

- **Ленивость**: `IO` ничего не делает до тех пор, пока его не "запустят" (вызовут как функцию). Он просто **описывает** эффект.
- **Чистота**: Создание `IO` — это чистая операция. Мы не выполняем эффект, а лишь создаем его описание.

Давайте перепишем `greet` с использованием `IO`:

```typescript
import { IO } from 'fp-ts/IO';

// Теперь greet - чистая функция. Она не выполняет лог, а возвращает его описание.
const greetIO = (name: string): IO<void> =>
  () => console.log(`Hello, ${name}`);

// Чтобы эффект произошел, мы должны запустить IO
const effectDescription = greetIO('World'); // Ничего не выводится в консоль
effectDescription(); // В консоли появится "Hello, World"
```
Мы отделили **создание** эффекта от его **выполнения**.

## 3. Композиция `IO`

`IO` — это монада, а значит, мы можем использовать `pipe` и `IO.chain` для создания цепочек из синхронных эффектов, не запуская их.

Предположим, у нас есть `IO` для чтения из `prompt` и `IO` для вывода в консоль.

```typescript
import { pipe } from 'fp-ts/function';
import * as IO from 'fp-ts/IO';

const read: IO<string> = () => window.prompt('Как тебя зовут?') || 'незнакомец';
const write = (text: string): IO<void> => () => console.log(text);

// Создаем программу как одно IO-значение
const program = pipe(
  read, // IO<string>
  IO.chain(name => write(`Привет, ${name}!`)) // IO.chain "распаковывает" name и передает его дальше
);

// Вся наша программа - это `program`.
// Мы можем передавать ее, сохранять, и т.д.
// И только в самом конце, на "границе мира", мы ее запускаем.
program(); // Запускает prompt, затем console.log
```

## 4. Применение в нашей игре

Мы можем создать модуль `logger.ts`, который предоставит нам `IO`-обертки над `console.log`, `console.error` и т.д.

**`logger.ts`**
```typescript
import { IO } from 'fp-ts/IO';

export interface Logger {
  log: (message: unknown) => IO<void>;
  error: (message: unknown) => IO<void>;
}

export const ioLogger: Logger = {
  log: (message) => () => console.log(message),
  error: (message) => () => console.error(message),
};
```

Затем в `main.ts` мы сможем заменить прямые вызовы `console.log` на вызовы нашего логгера. Это сделает код более тестируемым и функционально чистым. Например, в тестах мы сможем подменить `ioLogger` на мок-объект, который будет собирать сообщения в массив вместо вывода в консоль.
