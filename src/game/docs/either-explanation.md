# Конспект: `fp-ts/Either`

## 1. Что такое `Either`?

`Either` — это алгебраический тип данных в `fp-ts`, который представляет вычисление, которое может либо **успешно завершиться**, либо **провалиться**. Это контейнер, который в любой момент времени может содержать одно из двух возможных значений:

- **`Right<R>`**: Представляет успешный результат. По соглашению, это "правильная" (Right) сторона и содержит значение типа `R`.
- **`Left<L>`**: Представляет ошибку или неудачу. Это "левая" (Left) сторона и содержит значение ошибки типа `L`.

Сигнатура типа `Either<L, R>` ясно указывает, что результат может быть либо ошибкой типа `L`, либо успешным значением типа `R`.

## 2. Зачем нужен `Either`? Проблемы традиционной обработки ошибок

Традиционные методы обработки ошибок, такие как `try/catch` или возвращение `null`/`undefined`, имеют недостатки:

- **`try/catch`**: Нарушает естественный поток выполнения программы, усложняет композицию функций и может быть тяжело отследить, откуда именно возникло исключение.
- **`null`/`undefined`**: Приводит к необходимости постоянных проверок на `null`/`undefined`, что легко забыть, и это может вызвать `TypeError` в рантайме. Компилятор TypeScript не всегда может гарантировать, что эти проверки выполнены.

`Either` решает эти проблемы, делая обработку ошибок **явной**, **компонуемой** и **безопасной** на уровне типов.

## 3. Основные операции с `Either`

### Создание `Either`

```typescript
import { right, left } from 'fp-ts/Either';

// Успешный результат
const successValue = right(123); // Тип: Either<never, number>
// Неудачный результат (ошибка)
const failureValue = left('Что-то пошло не так'); // Тип: Either<string, never>
```

### `map`

Применяет функцию к **успешному** значению (`Right`), если оно есть. Если `Either` содержит `Left` (ошибку), то функция не применяется, и `Left` передается дальше без изменений.

```typescript
import { right, left, map } from 'fp-ts/Either';

const safeDivide = (a: number, b: number): Either<string, number> =>
  b === 0 ? left('Деление на ноль!') : right(a / b);

const result1 = map((x: number) => x * 2)(safeDivide(10, 2));
// result1 будет right(10) (10 / 2 = 5, затем 5 * 2 = 10)

const result2 = map((x: number) => x * 2)(safeDivide(10, 0));
// result2 будет left('Деление на ноль!') (операция не выполнилась из-за Left)
```

### `chain` (или `flatMap`)

Применяет функцию, которая *сама возвращает `Either`*, к **успешному** значению. Это позволяет последовательно выполнять операции, каждая из которых может завершиться ошибкой.

- Если текущий `Either` является `Right`, функция применяется, и результат (который тоже `Either`) становится следующим шагом в цепочке.
- Если текущий `Either` является `Left`, функция не применяется, и `Left` просто передается дальше по цепочке, прерывая дальнейшие вычисления.

```typescript
import { right, left, chain } from 'fp-ts/Either';
import { pipe } from 'fp-ts/function'; // Необходим для pipe

const parseNumber = (s: string): Either<string, number> => {
  const num = parseInt(s, 10);
  return isNaN(num) ? left(`Не удалось распарсить: "${s}"`) : right(num);
};

// Цепочка операций: распарсить две строки, затем безопасно разделить
const processStringsAndDivide = (s1: string, s2: string): Either<string, number> =>
  pipe(
    parseNumber(s1), // Either<string, number>
    chain(num1 => pipe( // Если num1 успешен, продолжаем
      parseNumber(s2), // Either<string, number>
      chain(num2 => safeDivide(num1, num2)) // Если num2 успешен, делим num1 на num2
    ))
  );

// Примеры использования
console.log(processStringsAndDivide('10', '2'));   // right(5)
console.log(processStringsAndDivide('abc', '2'));  // left('Не удалось распарсить: "abc"')
console.log(processStringsAndDivide('10', '0'));   // left('Деление на ноль!')
console.log(processStringsAndDivide('10', 'xyz')); // left('Не удалось распарсить: "xyz"')
```

### `fold`

`fold` позволяет "развернуть" `Either` в обычное значение, предоставляя две функции: одну для обработки `Left` (случай ошибки), другую для обработки `Right` (случай успеха). Это безопасный способ извлечь значение из `Either`.

```typescript
import { right, left, fold } from 'fp-ts/Either';

const displayResult = (e: Either<string, number>): string =>
  fold(
    (error: string) => `Произошла ошибка: ${error}`, // Функция для Left
    (value: number) => `Результат: ${value}`       // Функция для Right
  )(e);

console.log(displayResult(right(5)));              // "Результат: 5"
console.log(displayResult(left('Что-то пошло не так'))); // "Произошла ошибка: Что-то пошло не так"
```

## 4. Применение `Either` для `settings.json`

Мы будем использовать `Either` для безопасного чтения и парсинга файла `settings.json`:

1.  **Чтение файла**: Попытка прочитать файл может завершиться ошибкой (файл не найден, нет прав). `Either` поможет нам представить эту возможность.
2.  **Парсинг JSON**: Даже если файл прочитан, его содержимое может быть некорректным JSON. `Either` снова поможет безопасно обработать эту ситуацию.
3.  **Валидация данных**: Полученный объект может не соответствовать ожидаемой структуре настроек. И здесь `Either` будет полезен.

В следующем упражнении мы попрактикуемся в этом.
